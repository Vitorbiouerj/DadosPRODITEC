


import pandas as pd
import os


# Lista de arquivos CSV para processar
arquivos_csv = ["dados_2024.csv", "dados_2025.csv", "consolidado_matriculas.csv"]  # Substitua pelos arquivos reais

# Número de linhas que deseja extrair do head
num_linhas = 5  # Altere conforme necessário

# Loop para processar cada arquivo
for arquivo in arquivos_csv:
    if os.path.exists(arquivo):  # Verifica se o arquivo existe
        df = pd.read_csv(arquivo)  # Carrega o CSV
        df_head = df.head(num_linhas)  # Obtém as primeiras linhas

        # Nome do novo arquivo com prefixo head_
        novo_nome = f"head_{arquivo}"

        # Salva o novo arquivo CSV
        df_head.to_csv(novo_nome, index=False)
        print(f"Arquivo gerado: {novo_nome}")
    else:
        print(f"Arquivo não encontrado: {arquivo}")





# Carregar os arquivos CSV
consolidado_matriculas = pd.read_csv("consolidado_matriculas.csv")
dados_2024 = pd.read_csv("dados_2024.csv")
dados_2025 = pd.read_csv("dados_2025.csv")

# Agregar os dados dos alunos do PRODITEC por município (2024 e 2025)
participantes_2024 = dados_2024.groupby("NOME MUNICÍPIO").size().reset_index(name="N_PARTICIPANTES_2024")
participantes_2025 = dados_2025.groupby("NOME MUNICÍPIO").size().reset_index(name="N_PARTICIPANTES_2025")

# Unir os dados dos participantes em um único DataFrame
participantes = pd.merge(participantes_2024, participantes_2025, on="NOME MUNICÍPIO", how="outer").fillna(0)

# Criar coluna total de participantes
participantes["N_PARTICIPANTES"] = participantes["N_PARTICIPANTES_2024"] + participantes["N_PARTICIPANTES_2025"]

# Exibir o resultado
participantes.head()


merged_data = pd.merge(consolidado_matriculas, participantes, on="NOME MUNICÍPIO", how="left").fillna(0)
merged_data.head(10)





# Remover colunas desnecessárias
colunas_para_excluir = ['POSSUI INTERNET', 'INTERNET BANDA LARGA', 'PROF MONITORES', 'AEE', 'ATIVIDADE COMPLEMENTAR', 
                        'ESCOLARIZACAO', 'ENSINO INFANTIL', 'ENSINO FUNDAMENTAL', 'ENSINO MÉDIO', 
                        'ENSINO PROFISIONALIZANTE', 'ENSINO TÉC. PROF.', 'EJA', 'EDUCAÇÃO ESPECIAL']
consolidado_matriculas = consolidado_matriculas.drop(columns=colunas_para_excluir, errors='ignore')

# Agregar escolas por município
escolas_por_municipio = consolidado_matriculas.groupby("NOME MUNICÍPIO").size().reset_index(name="QT_ESCOLAS")


# Unir os dados de escolas e participantes
merged_data = pd.merge(escolas_por_municipio, participantes, on="NOME MUNICÍPIO", how="left").fillna(0)
merged_data.head(10)


# Calcular a correlação entre número de escolas e número de participantes
pearson_corr = merged_data["QT_ESCOLAS"].corr(merged_data["N_PARTICIPANTES"], method="pearson")
spearman_corr = merged_data["QT_ESCOLAS"].corr(merged_data["N_PARTICIPANTES"], method="spearman")

# Criar DataFrame com os resultados da correlação
tabela_correlacao = pd.DataFrame({"Correlação": [pearson_corr, spearman_corr]}, index=["Pearson", "Spearman"])

# Exibir os resultados
tabela_correlacao

















# Carregar os arquivos CSV
consolidado_matriculas = pd.read_csv("consolidado_matriculas.csv")
dados_2024 = pd.read_csv("dados_2024.csv")
dados_2025 = pd.read_csv("dados_2025.csv")


# Renomear a coluna para manter consistência
dados_2024 = dados_2024.rename(columns={'SIGLA UF': 'UF'})
dados_2025 = dados_2025.rename(columns={'SIGLA UF': 'UF'})


# Agregar participantes por estado (2024 e 2025)
participantes_2024_estado = dados_2024.groupby("UF").size().reset_index(name="N_PARTICIPANTES_2024")
participantes_2025_estado = dados_2025.groupby("UF").size().reset_index(name="N_PARTICIPANTES_2025")

# Unir os dados dos participantes em um único DataFrame por estado
participantes_estado = pd.merge(participantes_2024_estado, participantes_2025_estado, on="UF", how="outer").fillna(0)

# Criar coluna total de participantes por estado
participantes_estado["N_PARTICIPANTES_ESTADO"] = participantes_estado["N_PARTICIPANTES_2024"] + participantes_estado["N_PARTICIPANTES_2025"]

# Exibir o resultado
participantes_estado.head()


consolidado_matriculas.head()


# Agregar escolas por estado
escolas_por_estado = consolidado_matriculas.groupby("UF").size().reset_index(name="QT_ESCOLAS_ESTADO")

# Agregar participantes por estado (2024 e 2025)
participantes_2024_estado = dados_2024.groupby("UF").size().reset_index(name="N_PARTICIPANTES_2024")
participantes_2025_estado = dados_2025.groupby("UF").size().reset_index(name="N_PARTICIPANTES_2025")

# Unir os dados dos participantes em um único DataFrame por estado
participantes_estado = pd.merge(participantes_2024_estado, participantes_2025_estado, on="UF", how="outer").fillna(0)

# Criar coluna total de participantes por estado
participantes_estado["N_PARTICIPANTES_ESTADO"] = participantes_estado["N_PARTICIPANTES_2024"] + participantes_estado["N_PARTICIPANTES_2025"]


# Unir os dados de escolas e participantes por estado
merged_data_estado = pd.merge(escolas_por_estado, participantes_estado, on="UF", how="left").fillna(0)
merged_data_estado.head()


# Calcular a correlação entre número de escolas e número de participantes por estado
pearson_corr_estado = merged_data_estado["QT_ESCOLAS_ESTADO"].corr(merged_data_estado["N_PARTICIPANTES_ESTADO"], method="pearson")
spearman_corr_estado = merged_data_estado["QT_ESCOLAS_ESTADO"].corr(merged_data_estado["N_PARTICIPANTES_ESTADO"], method="spearman")

# Criar DataFrame com os resultados da correlação por estado
tabela_correlacao_estado = pd.DataFrame({"Correlação": [pearson_corr_estado, spearman_corr_estado]}, index=["Pearson", "Spearman"])

# Exibir os resultados
tabela_correlacao_estado

















# Carregar os arquivos CSV
consolidado_matriculas = pd.read_csv("consolidado_matriculas.csv")
dados_2024 = pd.read_csv("dados_2024.csv")
dados_2025 = pd.read_csv("dados_2025.csv")


# Renomear a coluna para manter consistência
dados_2024 = dados_2024.rename(columns={'SIGLA UF': 'UF'})
dados_2025 = dados_2025.rename(columns={'SIGLA UF': 'UF'})


# Carregar os arquivos CSV
consolidado_matriculas = pd.read_csv("consolidado_matriculas.csv")
dados_2024 = pd.read_csv("dados_2024.csv")
dados_2025 = pd.read_csv("dados_2025.csv")

# Agregar os dados dos alunos do PRODITEC por município (2024 e 2025)
participantes_2024 = dados_2024.groupby("NOME MUNICÍPIO").size().reset_index(name="N_PARTICIPANTES_2024")
participantes_2025 = dados_2025.groupby("NOME MUNICÍPIO").size().reset_index(name="N_PARTICIPANTES_2025")

# Unir os dados dos participantes em um único DataFrame
participantes = pd.merge(participantes_2024, participantes_2025, on="NOME MUNICÍPIO", how="outer").fillna(0)

# Criar coluna total de participantes
participantes["N_PARTICIPANTES"] = participantes["N_PARTICIPANTES_2024"] + participantes["N_PARTICIPANTES_2025"]

# Exibir o resultado
participantes.head()


# Unir dados de escolas com os participantes apenas de 2024 por município
merged_data_2024 = pd.merge(escolas_por_municipio, participantes_2024, on="NOME MUNICÍPIO", how="left").fillna(0)

# Calcular a correlação entre número de escolas e número de participantes (2024)
pearson_corr_2024_mun = merged_data_2024["QT_ESCOLAS"].corr(merged_data_2024["N_PARTICIPANTES_2024"], method="pearson")
spearman_corr_2024_mun = merged_data_2024["QT_ESCOLAS"].corr(merged_data_2024["N_PARTICIPANTES_2024"], method="spearman")

# Criar DataFrame com os resultados da correlação por município (2024)
tabela_correlacao_2024_mun = pd.DataFrame({"Correlação": [pearson_corr_2024_mun, spearman_corr_2024_mun]}, index=["Pearson", "Spearman"])


# Unir dados de escolas com os participantes apenas de 2025 por município
merged_data_2025 = pd.merge(escolas_por_municipio, participantes_2025, on="NOME MUNICÍPIO", how="left").fillna(0)

# Calcular a correlação entre número de escolas e número de participantes (2025)
pearson_corr_2025_mun = merged_data_2025["QT_ESCOLAS"].corr(merged_data_2025["N_PARTICIPANTES_2025"], method="pearson")
spearman_corr_2025_mun = merged_data_2025["QT_ESCOLAS"].corr(merged_data_2025["N_PARTICIPANTES_2025"], method="spearman")

# Criar DataFrame com os resultados da correlação por município (2025)
tabela_correlacao_2025_mun = pd.DataFrame({"Correlação": [pearson_corr_2025_mun, spearman_corr_2025_mun]}, index=["Pearson", "Spearman"])


# Unir dados de escolas com os participantes apenas de 2024 por UF
merged_data_2024_estado = pd.merge(escolas_por_estado, participantes_2024_estado, on="UF", how="left").fillna(0)

# Calcular a correlação entre número de escolas e número de participantes (2024) por UF
pearson_corr_2024_estado = merged_data_2024_estado["QT_ESCOLAS_ESTADO"].corr(merged_data_2024_estado["N_PARTICIPANTES_2024"], method="pearson")
spearman_corr_2024_estado = merged_data_2024_estado["QT_ESCOLAS_ESTADO"].corr(merged_data_2024_estado["N_PARTICIPANTES_2024"], method="spearman")

# Criar DataFrame com os resultados da correlação por estado (2024)
tabela_correlacao_2024_estado = pd.DataFrame({"Correlação": [pearson_corr_2024_estado, spearman_corr_2024_estado]}, index=["Pearson", "Spearman"])


# Unir dados de escolas com os participantes apenas de 2025 por UF
merged_data_2025_estado = pd.merge(escolas_por_estado, participantes_2025_estado, on="UF", how="left").fillna(0)

# Calcular a correlação entre número de escolas e número de participantes (2025) por UF
pearson_corr_2025_estado = merged_data_2025_estado["QT_ESCOLAS_ESTADO"].corr(merged_data_2025_estado["N_PARTICIPANTES_2025"], method="pearson")
spearman_corr_2025_estado = merged_data_2025_estado["QT_ESCOLAS_ESTADO"].corr(merged_data_2025_estado["N_PARTICIPANTES_2025"], method="spearman")

# Criar DataFrame com os resultados da correlação por estado (2025)
tabela_correlacao_2025_estado = pd.DataFrame({"Correlação": [pearson_corr_2025_estado, spearman_corr_2025_estado]}, index=["Pearson", "Spearman"])





tabela_correlacao_2024_mun


tabela_correlacao_2025_mun


tabela_correlacao_2024_estado


tabela_correlacao_2025_estado





# Unir dados de escolas com os participantes apenas de 2024 por município
merged_data_2024 = pd.merge(escolas_por_municipio, participantes_2024, on="NOME MUNICÍPIO", how="left").fillna(0)

# Calcular a correlação entre número de escolas e número de participantes (2024)
pearson_corr_2024_mun = merged_data_2024["QT_ESCOLAS"].corr(merged_data_2024["N_PARTICIPANTES_2024"], method="pearson")
spearman_corr_2024_mun = merged_data_2024["QT_ESCOLAS"].corr(merged_data_2024["N_PARTICIPANTES_2024"], method="spearman")

# Criar DataFrame com os resultados da correlação por município (2024)
tabela_correlacao_2024_mun = pd.DataFrame({"Correlação": [pearson_corr_2024_mun, spearman_corr_2024_mun]}, index=["Pearson", "Spearman"])


# Unir dados de escolas com os participantes apenas de 2025 por município
merged_data_2025 = pd.merge(escolas_por_municipio, participantes_2025, on="NOME MUNICÍPIO", how="left").fillna(0)

# Calcular a correlação entre número de escolas e número de participantes (2025)
pearson_corr_2025_mun = merged_data_2025["QT_ESCOLAS"].corr(merged_data_2025["N_PARTICIPANTES_2025"], method="pearson")
spearman_corr_2025_mun = merged_data_2025["QT_ESCOLAS"].corr(merged_data_2025["N_PARTICIPANTES_2025"], method="spearman")

# Criar DataFrame com os resultados da correlação por município (2025)
tabela_correlacao_2025_mun = pd.DataFrame({"Correlação": [pearson_corr_2025_mun, spearman_corr_2025_mun]}, index=["Pearson", "Spearman"])


import matplotlib.pyplot as plt

# Criar figura e eixos
fig, axs = plt.subplots(1, 3, figsize=(18, 5), sharey=True)

# Dados de 2024
axs[0].scatter(merged_data_2024["QT_ESCOLAS"], merged_data_2024["N_PARTICIPANTES_2024"], alpha=0.6, color='blue')
axs[0].set_title("Dispersão - 2024")
axs[0].set_xlabel("Número de Escolas no Município")
axs[0].set_ylabel("Participantes PRODITEC (2024)")

# Dados de 2025
axs[1].scatter(merged_data_2025["QT_ESCOLAS"], merged_data_2025["N_PARTICIPANTES_2025"], alpha=0.6, color='red')
axs[1].set_title("Dispersão - 2025")
axs[1].set_xlabel("Número de Escolas no Município")

# Dados combinados (2024 + 2025)
axs[2].scatter(merged_data["QT_ESCOLAS"], merged_data["N_PARTICIPANTES"], alpha=0.6, color='green')
axs[2].set_title("Dispersão - 2024 e 2025")
axs[2].set_xlabel("Número de Escolas no Município")

# Ajustar layout
plt.tight_layout()
plt.show()



merged_data_2024.columns


import geopandas as gpd
import folium
from folium.plugins import HeatMap

# Caminho para os arquivos de geometria
shapefile_municipios = "/home/vitor/IA/jupyter_notebook/BR_Municipios_2023.shp"

# Carregar os dados geoespaciais dos municípios
gdf_municipios = gpd.read_file(shapefile_municipios)

# Converter os nomes dos municípios para maiúsculas para garantir a fusão correta
gdf_municipios["NM_MUN"] = gdf_municipios["NM_MUN"].str.upper()
merged_data["NOME MUNICÍPIO"] = merged_data["NOME MUNICÍPIO"].str.upper()

# Unir os dados dos municípios com os dados do PRODITEC
gdf_municipios = gdf_municipios.merge(merged_data, left_on="NM_MUN", right_on="NOME MUNICÍPIO", how="left")


# Garantir que os valores de participantes sejam inteiros e sem NaN
gdf_municipios["N_PARTICIPANTES_2024"] = gdf_municipios["N_PARTICIPANTES_2024"].fillna(0).astype(int)

# Criar um mapa base para os participantes de 2024
mapa_2024 = folium.Map(location=[-15, -55], zoom_start=4)

# Adicionar marcadores para os municípios no mapa de 2024
for _, row in gdf_municipios.iterrows():
    if row["N_PARTICIPANTES_2024"] > 0:  # Apenas municípios com participantes
        folium.CircleMarker(
            location=[row.geometry.centroid.y, row.geometry.centroid.x],
            radius=(row["N_PARTICIPANTES_2024"] ** 0.5) * 7.5,  # Escala raiz quadrada para melhor visualização
            color="blue",
            fill=True,
            fill_color="blue",
            fill_opacity=0.6,
            popup=folium.Popup(f"{row['NM_MUN']}: {row['N_PARTICIPANTES_2024']} participantes", sticky=True)
        ).add_to(mapa_2024)



# Criar um mapa base para os participantes de 2025
mapa_2025 = folium.Map(location=[-15, -55], zoom_start=4)

# Adicionar marcadores para os municípios no mapa de 2025
for _, row in gdf_municipios.iterrows():
    if row["N_PARTICIPANTES_2025"] > 0:
        folium.CircleMarker(
            location=[row.geometry.centroid.y, row.geometry.centroid.x],
            radius=(row["N_PARTICIPANTES_2025"] ** 0.5) * 7.5,
            color="red",
            fill=True,
            fill_color="red",
            fill_opacity=0.6,
            popup=folium.Popup(f"{row['NM_MUN']}: {int(row['N_PARTICIPANTES'])} participantes", sticky=True)
        ).add_to(mapa_2025)


# Criar um mapa base para a soma de 2024 e 2025
mapa_total = folium.Map(location=[-15, -55], zoom_start=4)

# Adicionar marcadores para os municípios no mapa total
for _, row in gdf_municipios.iterrows():
    if row["N_PARTICIPANTES"] > 0:
        folium.CircleMarker(
            location=[row.geometry.centroid.y, row.geometry.centroid.x],
            radius=(row["N_PARTICIPANTES"] ** 0.5) * 7.5,
            color="green",
            fill=True,
            fill_color="green",
            fill_opacity=0.6,
            popup=folium.Popup(f"{row['NM_MUN']}: {int(row['N_PARTICIPANTES'])} participantes", sticky=True)
        ).add_to(mapa_total)





mapa_2024
mapa_2024.save("mapa_2024_bolha_distribuição.html")


mapa_2025
mapa_2025.save("mapa_2025_bolha_distribuição.html")


mapa_total
mapa_total.save("mapa_total_bolha_distribuição.html")








import folium
from folium.features import Choropleth

# Garantir que a sigla do estado está em maiúsculas para fusão correta
gdf_estados["SIGLA_UF"] = gdf_estados["SIGLA_UF"].str.upper()
merged_data_estado["UF"] = merged_data_estado["UF"].str.upper()


# Criar um mapa base para a proporção de 2024
mapa_coropletico_2024 = folium.Map(location=[-15, -55], zoom_start=4)

# Adicionar o mapa coroplético para 2024
Choropleth(
    geo_data=gdf_estados,
    name="Proporção de Participantes 2024",
    data=gdf_estados,
    columns=["SIGLA_UF", "PROP_PARTICIPANTES_2024"],  # Usar SIGLA_UF para unir os dados
    key_on="feature.properties.SIGLA_UF",
    fill_color="Blues",
    fill_opacity=0.7,
    line_opacity=0.2,
    legend_name="Proporção de Diretores/Técnicos no PRODITEC (2024)"
).add_to(mapa_coropletico_2024)


# Criar um mapa base para a proporção de 2025
mapa_coropletico_2025 = folium.Map(location=[-15, -55], zoom_start=4)

# Adicionar o mapa coroplético para 2025
Choropleth(
    geo_data=gdf_estados,
    name="Proporção de Participantes 2025",
    data=gdf_estados,
    columns=["SIGLA_UF", "PROP_PARTICIPANTES_2025"],  # Usar SIGLA_UF
    key_on="feature.properties.SIGLA_UF",
    fill_color="Reds",
    fill_opacity=0.7,
    line_opacity=0.2,
    legend_name="Proporção de Diretores/Técnicos no PRODITEC (2025)"
).add_to(mapa_coropletico_2025)


# Criar um mapa base para a proporção total
mapa_coropletico_total = folium.Map(location=[-15, -55], zoom_start=4)

# Adicionar o mapa coroplético para o total de 2024 e 2025
Choropleth(
    geo_data=gdf_estados,
    name="Proporção de Participantes Total",
    data=gdf_estados,
    columns=["SIGLA_UF", "PROP_PARTICIPANTES_TOTAL"],  # Usar SIGLA_UF
    key_on="feature.properties.SIGLA_UF",
    fill_color="Greens",
    fill_opacity=0.7,
    line_opacity=0.2,
    legend_name="Proporção de Diretores/Técnicos no PRODITEC (2024+2025)"
).add_to(mapa_coropletico_total)


# Exibir os mapas interativos
mapa_coropletico_2024


mapa_coropletico_2025


mapa_coropletico_total


print(set(gdf_estados["SIGLA_UF"]) - set(merged_data_estado["UF"]))


print(set(merged_data_estado["UF"]) - set(gdf_estados["SIGLA_UF"]))


print(gdf_estados[["SIGLA_UF", "N_PARTICIPANTES_2024", "N_PARTICIPANTES_2025", "N_PARTICIPANTES_ESTADO", "QT_ESCOLAS_ESTADO", "PROP_PARTICIPANTES_2024", "PROP_PARTICIPANTES_2025", "PROP_PARTICIPANTES_TOTAL"]])


# Normalizar os valores multiplicando por 100 para converter em porcentagem
gdf_estados["PROP_PARTICIPANTES_2024"] = ((gdf_estados["N_PARTICIPANTES_2024"] / gdf_estados["QT_ESCOLAS_ESTADO"]) * 100).fillna(0)
gdf_estados["PROP_PARTICIPANTES_2025"] = ((gdf_estados["N_PARTICIPANTES_2025"] / gdf_estados["QT_ESCOLAS_ESTADO"]) * 100).fillna(0)
gdf_estados["PROP_PARTICIPANTES_TOTAL"] = ((gdf_estados["N_PARTICIPANTES_ESTADO"] / gdf_estados["QT_ESCOLAS_ESTADO"]) * 100).fillna(0)


print(gdf_estados[["SIGLA_UF", "N_PARTICIPANTES_2024", "N_PARTICIPANTES_2025", "N_PARTICIPANTES_ESTADO", "QT_ESCOLAS_ESTADO", "PROP_PARTICIPANTES_2024", "PROP_PARTICIPANTES_2025", "PROP_PARTICIPANTES_TOTAL"]])


print(merged_data_estado.head())
print(gdf_estados.head())


# Garantir que os nomes das siglas estão uniformes (removendo espaços extras e convertendo para maiúsculas)
gdf_estados["SIGLA_UF"] = gdf_estados["SIGLA_UF"].str.strip().str.upper()
merged_data_estado["UF"] = merged_data_estado["UF"].str.strip().str.upper()


# Verificar se há diferenças entre as listas de siglas
print("Estados no shapefile e não no dataset:")
print(set(gdf_estados["SIGLA_UF"]) - set(merged_data_estado["UF"]))

print("Estados no dataset e não no shapefile:")
print(set(merged_data_estado["UF"]) - set(gdf_estados["SIGLA_UF"]))


print(merged_data_estado.dtypes)
print(merged_data_estado.head())


print(gdf_estados[gdf_estados["N_PARTICIPANTES_ESTADO"].isna()])


#===

# Verificar quais colunas existem antes da fusão
print("Colunas em gdf_estados antes da fusão:", gdf_estados.columns)
print("Colunas em merged_data_estado antes da fusão:", merged_data_estado.columns)

# Garantir que os nomes das siglas estão uniformes
gdf_estados["SIGLA_UF"] = gdf_estados["SIGLA_UF"].str.strip().str.upper()
merged_data_estado["UF"] = merged_data_estado["UF"].str.strip().str.upper()

# Refazer a fusão corretamente
gdf_estados = gdf_estados.merge(merged_data_estado, left_on="SIGLA_UF", right_on="UF", how="left")

#===

# Verificar quais colunas existem após a fusão
print("Colunas em gdf_estados depois da fusão:", gdf_estados.columns)

#===

# Verificar se os valores agora estão preenchidos corretamente
print(gdf_estados[["SIGLA_UF", "N_PARTICIPANTES_2024", "N_PARTICIPANTES_2025", "N_PARTICIPANTES_ESTADO", "QT_ESCOLAS_ESTADO"]].head())

#===

# Garantir que não há mais valores NaN
gdf_estados = gdf_estados.fillna(0)

# Verificar novamente
print(gdf_estados[["SIGLA_UF", "N_PARTICIPANTES_2024", "N_PARTICIPANTES_2025", "N_PARTICIPANTES_ESTADO", "QT_ESCOLAS_ESTADO"]].head())



#===

# Remover colunas duplicadas desnecessárias
gdf_estados = gdf_estados[[
    "SIGLA_UF", "geometry",  # Manter a sigla e a geometria
    "QT_ESCOLAS_ESTADO", "N_PARTICIPANTES_2024", "N_PARTICIPANTES_2025", "N_PARTICIPANTES_ESTADO"
]]

#===

# Recalcular as proporções agora que os dados estão certos
gdf_estados["PROP_PARTICIPANTES_2024"] = (gdf_estados["N_PARTICIPANTES_2024"] / gdf_estados["QT_ESCOLAS_ESTADO"]).fillna(0) * 100
gdf_estados["PROP_PARTICIPANTES_2025"] = (gdf_estados["N_PARTICIPANTES_2025"] / gdf_estados["QT_ESCOLAS_ESTADO"]).fillna(0) * 100
gdf_estados["PROP_PARTICIPANTES_TOTAL"] = (gdf_estados["N_PARTICIPANTES_ESTADO"] / gdf_estados["QT_ESCOLAS_ESTADO"]).fillna(0) * 100

#===

# Verificar os novos valores antes de gerar o mapa
print(gdf_estados[["SIGLA_UF", "PROP_PARTICIPANTES_2024", "PROP_PARTICIPANTES_2025", "PROP_PARTICIPANTES_TOTAL"]])



import folium
from folium.features import Choropleth
from folium.plugins import Fullscreen

# Criar um mapa base para a proporção de 2024
mapa_coropletico_2024 = folium.Map(location=[-15, -55], zoom_start=4)

# Adicionar modo tela cheia
Fullscreen(position="topright").add_to(mapa_coropletico_2024)

# Adicionar o mapa coroplético para 2024
Choropleth(
    geo_data=gdf_estados,
    name="Proporção de Cursistas pelo número de Escolas (2024) em %",
    data=gdf_estados,
    columns=["SIGLA_UF", "PROP_PARTICIPANTES_2024"],
    key_on="feature.properties.SIGLA_UF",
    fill_color="Blues",
    fill_opacity=0.7,
    line_opacity=0.2,
    legend_name="Proporção de Cursistas pelo número de Escolas (2024) em %"
).add_to(mapa_coropletico_2024)

#===

# Criar um mapa base para a proporção de 2025
mapa_coropletico_2025 = folium.Map(location=[-15, -55], zoom_start=4)

# Adicionar modo tela cheia
Fullscreen(position="topright").add_to(mapa_coropletico_2025)

# Adicionar o mapa coroplético para 2025
Choropleth(
    geo_data=gdf_estados,
    name="Proporção de Cursistas pelo número de Escolas (2025) em %",
    data=gdf_estados,
    columns=["SIGLA_UF", "PROP_PARTICIPANTES_2025"],
    key_on="feature.properties.SIGLA_UF",
    fill_color="Reds",
    fill_opacity=0.7,
    line_opacity=0.2,
    legend_name="Proporção de Cursistas pelo número de Escolas (2025) em %"
).add_to(mapa_coropletico_2025)

#===

# Criar um mapa base para a proporção total
mapa_coropletico_total = folium.Map(location=[-15, -55], zoom_start=4)

# Adicionar modo tela cheia
Fullscreen(position="topright").add_to(mapa_coropletico_total)

# Adicionar o mapa coroplético para o total de 2024 e 2025
Choropleth(
    geo_data=gdf_estados,
    name="Proporção de Cursistas pelo número de Escolas (2024+2025) em %",
    data=gdf_estados,
    columns=["SIGLA_UF", "PROP_PARTICIPANTES_TOTAL"],
    key_on="feature.properties.SIGLA_UF",
    fill_color="Greens",
    fill_opacity=0.7,
    line_opacity=0.2,
    legend_name="Proporção de Cursistas pelo número de Escolas (2024+2025) em %"
).add_to(mapa_coropletico_total)

# Exibir os mapas interativos


mapa_coropletico_2024
mapa_coropletico_2024.save("mapa_coropletico_2024_porcentagem.html")


mapa_coropletico_2025
mapa_coropletico_2025.save("mapa_coropletico_2025_porcentagem.html")


mapa_coropletico_total
mapa_coropletico_total.save("mapa_coropletico_total_porcentagem.html")



